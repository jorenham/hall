{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Caution: under development Hall is currently under development and is prone to interface changes. The documentation is currently incomplete, but will be coming soon. Hall is a lightweight library with pythonic syntax. Some features include: Clean, pythonic syntax that closely resembles mathematical notation in probability theory. Symbolic algebra and bayesian statistics with random variables. Calculations are numerically precise, with arbitrairy precision. Lightweight; it only requires mpmath . Fully type-annotated and mypy friendly Thoroughly tested. Example >>> from hall import P , E , Std , Normal , sample >>> IQ = ~ Normal () * 100 + 15 >>> E [ IQ ] 100.0 >>> Std [ IQ ] 15.0 >>> P ( IQ >= 130 ) 0.0227501319481792 >>> print ( \"IQ test outcome:\" , sample ( IQ )) IQ test outcome: 116.309834872963 So the chance of having an IQ (normally distributed with \u03bc=100 and \u03c3=15) of at least 130 is approximately 2.3%. What's going on here: IQ is a random variable with the normal distribution, scaled to have a mean of 100 and standard deviation of 15, i.e., \\( \\mathrm{IQ} \\sim \\mathcal N(100, 15^2) \\) . We verify this using the operators for the expectancy \\( \\operatorname E[\\cdot] \\) , and standard deviation \\( \\operatorname{Std}[\\cdot] \\) . Next, we obtain the probability of someone having an IQ of at least 130, \\( \\operatorname P (\\mathrm{IQ} \\ge 130) \\) . Finally, we draw a sample from the random variable with the hall.sample function. Rationale Coming soon","title":"Overview"},{"location":"#overview","text":"Caution: under development Hall is currently under development and is prone to interface changes. The documentation is currently incomplete, but will be coming soon. Hall is a lightweight library with pythonic syntax. Some features include: Clean, pythonic syntax that closely resembles mathematical notation in probability theory. Symbolic algebra and bayesian statistics with random variables. Calculations are numerically precise, with arbitrairy precision. Lightweight; it only requires mpmath . Fully type-annotated and mypy friendly Thoroughly tested.","title":"Overview"},{"location":"#example","text":">>> from hall import P , E , Std , Normal , sample >>> IQ = ~ Normal () * 100 + 15 >>> E [ IQ ] 100.0 >>> Std [ IQ ] 15.0 >>> P ( IQ >= 130 ) 0.0227501319481792 >>> print ( \"IQ test outcome:\" , sample ( IQ )) IQ test outcome: 116.309834872963 So the chance of having an IQ (normally distributed with \u03bc=100 and \u03c3=15) of at least 130 is approximately 2.3%. What's going on here: IQ is a random variable with the normal distribution, scaled to have a mean of 100 and standard deviation of 15, i.e., \\( \\mathrm{IQ} \\sim \\mathcal N(100, 15^2) \\) . We verify this using the operators for the expectancy \\( \\operatorname E[\\cdot] \\) , and standard deviation \\( \\operatorname{Std}[\\cdot] \\) . Next, we obtain the probability of someone having an IQ of at least 130, \\( \\operatorname P (\\mathrm{IQ} \\ge 130) \\) . Finally, we draw a sample from the random variable with the hall.sample function.","title":"Example"},{"location":"#rationale","text":"Coming soon","title":"Rationale"},{"location":"contributing/","text":"Contributing to Hall Any contributions to hall are appreciated! Issues Questions, feature requests and bug reports are all welcome as issues. When reporting a bug, make sure to include the versions of hall and mpmath you are using, as well as the backend ( hall.backend.get_backend() ), and provide a reproducable example of the bug. Development Ensure you have poetry installed, then poetry install Additionally, install pre-commit , then run: pre-commit install This adds git hooks that automatically formats and checks the code before commiting.","title":"Contributing to Hall"},{"location":"contributing/#contributing-to-hall","text":"Any contributions to hall are appreciated!","title":"Contributing to Hall"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. When reporting a bug, make sure to include the versions of hall and mpmath you are using, as well as the backend ( hall.backend.get_backend() ), and provide a reproducable example of the bug.","title":"Issues"},{"location":"contributing/#development","text":"Ensure you have poetry installed, then poetry install Additionally, install pre-commit , then run: pre-commit install This adds git hooks that automatically formats and checks the code before commiting.","title":"Development"},{"location":"install/","text":"Install Installation is as simple as: pip install hall Hall has no required dependencies except python 3.8, 3.9 or 3.10, and mpmath . If you have pip installed, you're good to go. Increase performance with gmpy (optional) Optionally, the gmpy2 dependency can be installed to significantly speed up the multi-precision arithmatical calculations. This adds bindings to the GMP ( MPIR on Windows), MPFR , and MPC libraries. On Ubuntu-based systems, these are installed with: apt install libgmp-dev libmpfr-dev libmpc-dev Now you can install the gmpy2 dependency with: pip install hall [ gmpy2 ] To verify that gmpy is installed, check the backend: >>> from hall.backend import get_backend >>> get_backend () 'gmpy'","title":"Install"},{"location":"install/#install","text":"Installation is as simple as: pip install hall Hall has no required dependencies except python 3.8, 3.9 or 3.10, and mpmath . If you have pip installed, you're good to go.","title":"Install"},{"location":"install/#increase-performance-with-gmpy-optional","text":"Optionally, the gmpy2 dependency can be installed to significantly speed up the multi-precision arithmatical calculations. This adds bindings to the GMP ( MPIR on Windows), MPFR , and MPC libraries. On Ubuntu-based systems, these are installed with: apt install libgmp-dev libmpfr-dev libmpc-dev Now you can install the gmpy2 dependency with: pip install hall [ gmpy2 ] To verify that gmpy is installed, check the backend: >>> from hall.backend import get_backend >>> get_backend () 'gmpy'","title":"Increase performance with gmpy (optional)"},{"location":"roadmap/","text":"Roadmap Hall is currently in the alpha phase and under development. At the moment, only basic random variable algebra and a handfull of distributions is implemented. My goal is to make Hall a reliable library that can be used in production environments, as well as a reliable tool to teaching probability theory. In upcoming releases, hall will add support for: Many of the commonly used discrete and continuous probability distributions Symbolic algebra of multiple random variables/vectors (without sympy), e.g., the birthday paradox is P(B1 == B2) where B1 and B2 are ~Uniform(1, 365) . Joint distributions and random vectors Conditional random variables, covariance, correlation, etc. Complex distributions Clean interface for user-defined distributions With lower probability, hall could also be able to: Statistical inference with symbolic parameters (likelihood-based, bayesian, etc.) Confidence intervals , with e.g. t- and z- tests. Optional numpy support (random matrices, and linear algebra thereof) Optional pandas support Optional numba or cupy support (for e.g. convolutions) to increase performance And with an even lower probability, hall might include support for: Stochastic processes , maybe even random fields Bayesian networks Mixture models Markov kernels Fuzzy logic Fuzzy sets Possiblity theory","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Hall is currently in the alpha phase and under development. At the moment, only basic random variable algebra and a handfull of distributions is implemented. My goal is to make Hall a reliable library that can be used in production environments, as well as a reliable tool to teaching probability theory. In upcoming releases, hall will add support for: Many of the commonly used discrete and continuous probability distributions Symbolic algebra of multiple random variables/vectors (without sympy), e.g., the birthday paradox is P(B1 == B2) where B1 and B2 are ~Uniform(1, 365) . Joint distributions and random vectors Conditional random variables, covariance, correlation, etc. Complex distributions Clean interface for user-defined distributions With lower probability, hall could also be able to: Statistical inference with symbolic parameters (likelihood-based, bayesian, etc.) Confidence intervals , with e.g. t- and z- tests. Optional numpy support (random matrices, and linear algebra thereof) Optional pandas support Optional numba or cupy support (for e.g. convolutions) to increase performance And with an even lower probability, hall might include support for: Stochastic processes , maybe even random fields Bayesian networks Mixture models Markov kernels Fuzzy logic Fuzzy sets Possiblity theory","title":"Roadmap"},{"location":"usage/","text":"Usage Coming soon","title":"Usage"},{"location":"usage/#usage","text":"Coming soon","title":"Usage"},{"location":"usage/#_1","text":"","title":""}]}